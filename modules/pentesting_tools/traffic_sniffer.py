"""
modules/pentesting_tools/traffic_sniffer.py

Captures and analyzes network traffic for potential security vulnerabilities.
"""

import socket
import struct
import textwrap
from datetime import datetime
from typing import Dict, Any


class TrafficSniffer:
    """
    A class to capture and analyze network traffic.
    """

    def __init__(self, interface: str):
        """
        Initializes the TrafficSniffer class.
        :param interface: Network interface to sniff traffic on.
        """
        self.interface = interface
        self.socket = None

    def initialize_socket(self):
        """
        Creates a raw socket for packet sniffing.
        """
        try:
            print(f"Initializing raw socket on interface {self.interface}")
            self.socket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))
            self.socket.bind((self.interface, 0))
        except PermissionError:
            raise PermissionError("Administrator/root privileges are required to sniff packets.")
        except Exception as e:
            raise Exception(f"Error initializing socket: {e}")

    def start_sniffing(self):
        """
        Starts sniffing packets.
        """
        if not self.socket:
            raise Exception("Socket not initialized. Call initialize_socket() first.")
        try:
            print(f"Sniffing on interface {self.interface}... Press Ctrl+C to stop.")
            while True:
                raw_data, addr = self.socket.recvfrom(65535)
                self.process_packet(raw_data)
        except KeyboardInterrupt:
            print("\nSniffing stopped.")
        except Exception as e:
            print(f"Error during sniffing: {e}")

    def process_packet(self, raw_data: bytes):
        """
        Processes a captured packet.
        :param raw_data: Raw packet data.
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] Packet captured:")
        dest_mac, src_mac, eth_proto, data = self._ethernet_frame(raw_data)
        print(f"Destination MAC: {dest_mac}, Source MAC: {src_mac}, Protocol: {eth_proto}")

        if eth_proto == 8:  # IPv4
            self._process_ipv4_packet(data)

    def _ethernet_frame(self, data: bytes) -> tuple:
        """
        Unpacks Ethernet frame.
        :param data: Raw packet data.
        :return: Unpacked Ethernet frame.
        """
        dest_mac, src_mac, proto = struct.unpack("!6s6sH", data[:14])
        return self._format_mac(dest_mac), self._format_mac(src_mac), socket.htons(proto), data[14:]

    def _format_mac(self, addr: bytes) -> str:
        """
        Formats MAC address as a human-readable string.
        :param addr: Raw MAC address.
        :return: Formatted MAC address.
        """
        return ":".join(map("{:02x}".format, addr)).upper()

    def _process_ipv4_packet(self, data: bytes):
        """
        Processes an IPv4 packet.
        :param data: Packet data.
        """
        version_header_length = data[0]
        header_length = (version_header_length & 15) * 4
        ttl, proto, src, target = struct.unpack("!8xBB2x4s4s", data[:20])
        src_ip = self._format_ipv4(src)
        target_ip = self._format_ipv4(target)

        print(f"IPv4 Packet -> Source: {src_ip}, Target: {target_ip}, TTL: {ttl}, Protocol: {proto}")
        if proto == 1:  # ICMP
            self._process_icmp_packet(data[header_length:])
        elif proto == 6:  # TCP
            self._process_tcp_segment(data[header_length:])
        elif proto == 17:  # UDP
            self._process_udp_segment(data[header_length:])

    def _format_ipv4(self, addr: bytes) -> str:
        """
        Formats IPv4 address as a human-readable string.
        :param addr: Raw IPv4 address.
        :return: Formatted IPv4 address.
        """
        return ".".join(map(str, addr))

    def _process_icmp_packet(self, data: bytes):
        """
        Processes an ICMP packet.
        :param data: Packet data.
        """
        icmp_type, code, checksum = struct.unpack("!BBH", data[:4])
        print(f"ICMP Packet -> Type: {icmp_type}, Code: {code}, Checksum: {checksum}")

    def _process_tcp_segment(self, data: bytes):
        """
        Processes a TCP segment.
        :param data: Segment data.
        """
        src_port, dest_port, sequence, acknowledgment, offset_reserved_flags = struct.unpack("!HHLLH", data[:14])
        offset = (offset_reserved_flags >> 12) * 4
        print(f"TCP Segment -> Source Port: {src_port}, Destination Port: {dest_port}, Sequence: {sequence}, Ack: {acknowledgment}")

    def _process_udp_segment(self, data: bytes):
        """
        Processes a UDP segment.
        :param data: Segment data.
        """
        src_port, dest_port, length, checksum = struct.unpack("!HHHH", data[:8])
        print(f"UDP Segment -> Source Port: {src_port}, Destination Port: {dest_port}, Length: {length}")


if __name__ == "__main__":
    # Example Usage
    sniffer = TrafficSniffer(interface="eth0")
    try:
        sniffer.initialize_socket()
        sniffer.start_sniffing()
    except Exception as e:
        print(f"Error: {e}")
