"""
modules/pentesting_tools/subdomain_enum.py

This module provides tools for enumerating subdomains of a target domain for reconnaissance purposes.
"""

import requests
import concurrent.futures
from dns import resolver, exception

class SubdomainEnumerator:
    """
    A tool for enumerating subdomains of a given domain.
    """

    def __init__(self, domain, wordlist_path=None):
        """
        Initializes the SubdomainEnumerator.
        :param domain: The target domain to enumerate subdomains for.
        :param wordlist_path: Path to a wordlist file for subdomain brute-forcing.
        """
        self.domain = domain
        self.wordlist_path = wordlist_path
        self.subdomains = []

    def enumerate_with_wordlist(self, threads=10):
        """
        Enumerates subdomains using a wordlist and DNS queries.
        :param threads: The number of threads to use for brute-forcing.
        :return: List of discovered subdomains.
        """
        if not self.wordlist_path:
            print("Error: No wordlist provided for brute-forcing.")
            return []

        print(f"Starting subdomain enumeration for: {self.domain} using wordlist {self.wordlist_path}")

        try:
            with open(self.wordlist_path, "r") as file:
                subdomain_candidates = [line.strip() for line in file]
        except FileNotFoundError:
            print(f"Error: Wordlist file {self.wordlist_path} not found.")
            return []

        discovered_subdomains = []

        def check_subdomain(subdomain):
            fqdn = f"{subdomain}.{self.domain}"
            try:
                resolver.resolve(fqdn, "A")
                print(f"Discovered subdomain: {fqdn}")
                return fqdn
            except (resolver.NXDOMAIN, resolver.NoAnswer, resolver.Timeout):
                return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = [executor.submit(check_subdomain, sub) for sub in subdomain_candidates]
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result:
                    discovered_subdomains.append(result)

        self.subdomains.extend(discovered_subdomains)
        return discovered_subdomains

    def enumerate_with_online_services(self, services=None):
        """
        Enumerates subdomains using online services (e.g., VirusTotal, SecurityTrails).
        :param services: List of online services to use for subdomain enumeration.
        :return: List of discovered subdomains.
        """
        if services is None:
            services = ["https://crt.sh", "https://api.hackertarget.com"]

        discovered_subdomains = []

        for service in services:
            print(f"Querying {service} for subdomains of {self.domain}...")
            try:
                if "crt.sh" in service:
                    response = requests.get(f"{service}/?q=%25.{self.domain}&output=json")
                    if response.status_code == 200:
                        subdomains = [
                            entry["name_value"]
                            for entry in response.json()
                            if "name_value" in entry
                        ]
                        discovered_subdomains.extend(subdomains)
                elif "hackertarget" in service:
                    response = requests.get(f"{service}/hostsearch/?q={self.domain}")
                    if response.status_code == 200:
                        subdomains = [line.split(",")[0] for line in response.text.splitlines()]
                        discovered_subdomains.extend(subdomains)
            except Exception as e:
                print(f"Error querying {service}: {e}")

        unique_subdomains = list(set(discovered_subdomains))
        print(f"Discovered {len(unique_subdomains)} subdomains using online services.")
        self.subdomains.extend(unique_subdomains)
        return unique_subdomains

    def save_results(self, output_path):
        """
        Saves the discovered subdomains to a file.
        :param output_path: Path to the output file.
        """
        with open(output_path, "w") as file:
            for subdomain in self.subdomains:
                file.write(f"{subdomain}\n")
        print(f"Results saved to {output_path}")

if __name__ == "__main__":
    # Example Usage
    target_domain = "example.com"
    wordlist = "wordlists/subdomains.txt"
    output_file = "results/subdomains.txt"

    enumerator = SubdomainEnumerator(target_domain, wordlist)

    # Enumerate subdomains using a wordlist
    print("Starting brute-force subdomain enumeration...")
    discovered_with_wordlist = enumerator.enumerate_with_wordlist()
    print(f"Discovered subdomains using wordlist: {discovered_with_wordlist}")

    # Enumerate subdomains using online services
    print("Starting online service-based subdomain enumeration...")
    discovered_with_services = enumerator.enumerate_with_online_services()
    print(f"Discovered subdomains using online services: {discovered_with_services}")

    # Save results
    enumerator.save_results(output_file)
