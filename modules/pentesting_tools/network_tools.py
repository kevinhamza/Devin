"""
modules/pentesting_tools/network_tools.py

This module contains tools for network scanning and penetration testing.
It provides capabilities to perform network reconnaissance, discover devices,
scan ports, detect services, and identify vulnerabilities.
"""

import socket
import ipaddress
import subprocess
from scapy.all import ARP, Ether, srp
from concurrent.futures import ThreadPoolExecutor

class NetworkTools:
    """
    Provides network scanning and penetration tools.
    """

    @staticmethod
    def get_local_ip():
        """
        Gets the local machine's IP address.
        :return: Local IP address as a string.
        """
        hostname = socket.gethostname()
        local_ip = socket.gethostbyname(hostname)
        return local_ip

    @staticmethod
    def is_port_open(host, port):
        """
        Checks if a port is open on a given host.
        :param host: Host IP or domain name.
        :param port: Port number to check.
        :return: True if the port is open, False otherwise.
        """
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(1)
                if sock.connect_ex((host, port)) == 0:
                    return True
        except Exception as e:
            print(f"Error checking port: {e}")
        return False

    @staticmethod
    def scan_ports(host, ports):
        """
        Scans a list of ports on a given host.
        :param host: Host IP or domain name.
        :param ports: List of port numbers to scan.
        :return: Dictionary of open ports.
        """
        open_ports = {}
        for port in ports:
            if NetworkTools.is_port_open(host, port):
                open_ports[port] = "Open"
        return open_ports

    @staticmethod
    def scan_network(network_cidr):
        """
        Scans a network for active devices.
        :param network_cidr: Network in CIDR notation (e.g., "192.168.1.0/24").
        :return: List of active devices with their IP and MAC addresses.
        """
        arp = ARP(pdst=network_cidr)
        ether = Ether(dst="ff:ff:ff:ff:ff:ff")
        packet = ether / arp
        result = srp(packet, timeout=3, verbose=0)[0]

        devices = []
        for sent, received in result:
            devices.append({'ip': received.psrc, 'mac': received.hwsrc})
        return devices

    @staticmethod
    def ping_sweep(network_cidr):
        """
        Performs a ping sweep on a network to discover active hosts.
        :param network_cidr: Network in CIDR notation (e.g., "192.168.1.0/24").
        :return: List of responsive hosts.
        """
        hosts = [str(ip) for ip in ipaddress.IPv4Network(network_cidr, strict=False)]
        responsive_hosts = []

        def ping(host):
            try:
                response = subprocess.run(
                    ["ping", "-c", "1", host], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                )
                if response.returncode == 0:
                    return host
            except Exception as e:
                print(f"Error pinging {host}: {e}")
            return None

        with ThreadPoolExecutor(max_workers=10) as executor:
            results = executor.map(ping, hosts)

        for result in results:
            if result:
                responsive_hosts.append(result)

        return responsive_hosts

    @staticmethod
    def detect_os(ip):
        """
        Detects the operating system of a target machine using TTL analysis.
        :param ip: IP address of the target.
        :return: Detected operating system or None if unknown.
        """
        try:
            response = subprocess.run(
                ["ping", "-c", "1", ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
            )
            for line in response.stdout.splitlines():
                if "ttl" in line.lower():
                    ttl = int(line.split("ttl=")[-1].split()[0])
                    if ttl == 64:
                        return "Linux/Unix-based OS"
                    elif ttl == 128:
                        return "Windows-based OS"
                    elif ttl == 255:
                        return "Cisco/Network device"
        except Exception as e:
            print(f"Error detecting OS: {e}")
        return None


if __name__ == "__main__":
    # Example Usage
    tools = NetworkTools()

    print("Local IP:", tools.get_local_ip())

    print("\nScanning Ports on '127.0.0.1':")
    open_ports = tools.scan_ports("127.0.0.1", range(1, 1025))
    for port, status in open_ports.items():
        print(f"Port {port}: {status}")

    print("\nScanning Network (192.168.1.0/24):")
    devices = tools.scan_network("192.168.1.0/24")
    for device in devices:
        print(f"IP: {device['ip']}, MAC: {device['mac']}")

    print("\nPing Sweep (192.168.1.0/24):")
    active_hosts = tools.ping_sweep("192.168.1.0/24")
    for host in active_hosts:
        print(f"Active Host: {host}")

    print("\nDetecting OS for '192.168.1.1':")
    os = tools.detect_os("192.168.1.1")
    print(f"Detected OS: {os if os else 'Unknown'}")
