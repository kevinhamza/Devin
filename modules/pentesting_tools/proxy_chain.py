"""
modules/pentesting_tools/proxy_chain.py

Implements functionality for chaining multiple proxies to anonymize and analyze network traffic.
"""

import socket
import threading
from typing import List, Tuple


class ProxyChain:
    """
    A class to manage a chain of proxies for forwarding traffic.
    """

    def __init__(self, proxy_list: List[Tuple[str, int]]):
        """
        Initializes the proxy chain.
        :param proxy_list: List of proxies in the format [(host1, port1), (host2, port2), ...].
        """
        self.proxy_list = proxy_list

    def create_chain(self, destination_host: str, destination_port: int) -> socket.socket:
        """
        Establishes a connection to the destination through the proxy chain.
        :param destination_host: Target host.
        :param destination_port: Target port.
        :return: Socket connected to the final destination through the proxy chain.
        """
        current_socket = None
        try:
            for proxy_host, proxy_port in self.proxy_list:
                print(f"Connecting to proxy {proxy_host}:{proxy_port}")
                current_socket = self.connect_to_proxy(proxy_host, proxy_port, current_socket)
            print(f"Connecting to destination {destination_host}:{destination_port}")
            self.connect_to_destination(current_socket, destination_host, destination_port)
            return current_socket
        except Exception as e:
            print(f"Error creating proxy chain: {e}")
            if current_socket:
                current_socket.close()
            raise

    @staticmethod
    def connect_to_proxy(proxy_host: str, proxy_port: int, parent_socket: socket.socket = None) -> socket.socket:
        """
        Connects to a single proxy in the chain.
        :param proxy_host: Proxy host.
        :param proxy_port: Proxy port.
        :param parent_socket: Existing socket (if chaining).
        :return: Connected socket.
        """
        try:
            proxy_socket = socket.create_connection((proxy_host, proxy_port))
            if parent_socket:
                threading.Thread(target=ProxyChain.forward_traffic, args=(parent_socket, proxy_socket)).start()
                threading.Thread(target=ProxyChain.forward_traffic, args=(proxy_socket, parent_socket)).start()
            return proxy_socket
        except Exception as e:
            print(f"Error connecting to proxy {proxy_host}:{proxy_port}: {e}")
            raise

    @staticmethod
    def connect_to_destination(proxy_socket: socket.socket, destination_host: str, destination_port: int):
        """
        Sends a CONNECT request to the final destination via the last proxy in the chain.
        :param proxy_socket: Last proxy socket in the chain.
        :param destination_host: Destination host.
        :param destination_port: Destination port.
        """
        try:
            connect_request = f"CONNECT {destination_host}:{destination_port} HTTP/1.1\r\n\r\n"
            proxy_socket.sendall(connect_request.encode())
            response = proxy_socket.recv(4096)
            if b"200 Connection established" not in response:
                raise ConnectionError(f"Proxy failed to connect: {response.decode()}")
        except Exception as e:
            print(f"Error connecting to destination through proxy: {e}")
            raise

    @staticmethod
    def forward_traffic(source_socket: socket.socket, destination_socket: socket.socket):
        """
        Forwards traffic between two sockets.
        :param source_socket: Source socket.
        :param destination_socket: Destination socket.
        """
        try:
            while True:
                data = source_socket.recv(4096)
                if not data:
                    break
                destination_socket.sendall(data)
        except Exception as e:
            print(f"Traffic forwarding error: {e}")
        finally:
            source_socket.close()
            destination_socket.close()


class ProxyChainTester:
    """
    A tester class for ProxyChain functionality.
    """

    @staticmethod
    def test_proxy_chain(proxy_list: List[Tuple[str, int]], destination_host: str, destination_port: int):
        """
        Tests the proxy chain by sending a simple HTTP request.
        :param proxy_list: List of proxies [(host1, port1), (host2, port2), ...].
        :param destination_host: Target host.
        :param destination_port: Target port.
        """
        try:
            chain = ProxyChain(proxy_list)
            proxy_socket = chain.create_chain(destination_host, destination_port)
            request = f"GET / HTTP/1.1\r\nHost: {destination_host}\r\n\r\n"
            proxy_socket.sendall(request.encode())
            response = proxy_socket.recv(4096)
            print(f"Response received:\n{response.decode()}")
        except Exception as e:
            print(f"Proxy chain test failed: {e}")


if __name__ == "__main__":
    # Example Usage
    proxy_list = [("proxy1.example.com", 8080), ("proxy2.example.com", 8080)]
    destination = ("example.com", 80)
    
    ProxyChainTester.test_proxy_chain(proxy_list, *destination)
