"""
modules/pentesting_tools/vulnerability_management.py
Manages vulnerability database, performs updates, queries, and integrations.
"""

import os
import json
from datetime import datetime
from typing import List, Dict, Optional

class VulnerabilityDatabase:
    """Manages a database of known vulnerabilities."""

    def __init__(self, db_file: str = "vulnerability_db.json"):
        self.db_file = db_file
        self.vulnerabilities = self.load_database()

    def load_database(self) -> List[Dict]:
        """Loads the database of vulnerabilities from a file."""
        if os.path.exists(self.db_file):
            with open(self.db_file, 'r') as f:
                return json.load(f)
        return []

    def save_database(self) -> None:
        """Saves the current state of the vulnerability database to a file."""
        with open(self.db_file, 'w') as f:
            json.dump(self.vulnerabilities, f, indent=4)

    def add_vulnerability(self, vulnerability: Dict) -> None:
        """Adds a new vulnerability to the database."""
        vulnerability['added_on'] = datetime.now().isoformat()
        self.vulnerabilities.append(vulnerability)
        self.save_database()

    def query_vulnerabilities(self, criteria: Optional[Dict] = None) -> List[Dict]:
        """Queries vulnerabilities based on criteria."""
        if not criteria:
            return self.vulnerabilities

        return [
            vuln for vuln in self.vulnerabilities
            if all(vuln.get(key) == value for key, value in criteria.items())
        ]

    def update_vulnerability(self, vuln_id: str, updates: Dict) -> bool:
        """Updates a vulnerability in the database."""
        for vuln in self.vulnerabilities:
            if vuln.get("id") == vuln_id:
                vuln.update(updates)
                self.save_database()
                return True
        return False

    def delete_vulnerability(self, vuln_id: str) -> bool:
        """Deletes a vulnerability from the database."""
        initial_count = len(self.vulnerabilities)
        self.vulnerabilities = [
            vuln for vuln in self.vulnerabilities if vuln.get("id") != vuln_id
        ]
        if len(self.vulnerabilities) < initial_count:
            self.save_database()
            return True
        return False


class VulnerabilityIntegration:
    """Handles integration with external vulnerability feeds."""

    def __init__(self, database: VulnerabilityDatabase):
        self.database = database

    def fetch_from_external_source(self, source_url: str) -> List[Dict]:
        """Simulates fetching vulnerabilities from an external source."""
        # Placeholder for actual fetching logic
        print(f"Fetching vulnerabilities from {source_url}")
        return [
            {"id": "CVE-2024-0001", "description": "Example vulnerability 1", "severity": "High"},
            {"id": "CVE-2024-0002", "description": "Example vulnerability 2", "severity": "Medium"},
        ]

    def sync_with_external_source(self, source_url: str) -> None:
        """Syncs the local database with an external vulnerability feed."""
        external_vulns = self.fetch_from_external_source(source_url)
        for vuln in external_vulns:
            if not any(v['id'] == vuln['id'] for v in self.database.vulnerabilities):
                self.database.add_vulnerability(vuln)


# Example usage
if __name__ == "__main__":
    db = VulnerabilityDatabase()
    integration = VulnerabilityIntegration(db)

    print("Syncing vulnerabilities...")
    integration.sync_with_external_source("https://example.com/vuln-feed")

    print("Current vulnerabilities:")
    for vuln in db.query_vulnerabilities():
        print(vuln)
