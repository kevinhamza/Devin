"""
modules/pentesting_tools/crypto_analysis_tools.py

Provides tools for analyzing cryptographic implementations, detecting weaknesses, and testing encryption/decryption processes.
"""

from typing import Optional, List, Dict
import hashlib
import base64
from Crypto.Cipher import AES, DES, RSA
from Crypto.PublicKey import RSA as RSAKey
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad


class CryptoAnalyzer:
    """
    A class for performing cryptographic analysis and testing.
    """

    @staticmethod
    def hash_file(file_path: str, algorithm: str = "sha256") -> Optional[str]:
        """
        Computes the hash of a file using the specified algorithm.
        :param file_path: Path to the file.
        :param algorithm: Hashing algorithm (e.g., 'sha256', 'md5').
        :return: Hexadecimal hash string or None if the operation fails.
        """
        print(f"Hashing file {file_path} using {algorithm}...")
        try:
            hash_func = getattr(hashlib, algorithm)
            with open(file_path, 'rb') as f:
                file_data = f.read()
            file_hash = hash_func(file_data).hexdigest()
            print(f"File hash: {file_hash}")
            return file_hash
        except AttributeError:
            print(f"Error: Unsupported hashing algorithm {algorithm}.")
        except Exception as e:
            print(f"Error hashing file: {e}")
        return None

    @staticmethod
    def encrypt_aes(data: bytes, key: bytes) -> bytes:
        """
        Encrypts data using AES encryption.
        :param data: Data to encrypt.
        :param key: AES key (must be 16, 24, or 32 bytes long).
        :return: Encrypted data.
        """
        print("Encrypting data using AES...")
        cipher = AES.new(key, AES.MODE_CBC)
        iv = cipher.iv
        encrypted_data = cipher.encrypt(pad(data, AES.block_size))
        print("Data encrypted successfully.")
        return iv + encrypted_data

    @staticmethod
    def decrypt_aes(data: bytes, key: bytes) -> Optional[bytes]:
        """
        Decrypts AES-encrypted data.
        :param data: Encrypted data (IV + ciphertext).
        :param key: AES key (must be 16, 24, or 32 bytes long).
        :return: Decrypted data or None if decryption fails.
        """
        print("Decrypting AES-encrypted data...")
        try:
            iv = data[:AES.block_size]
            cipher = AES.new(key, AES.MODE_CBC, iv)
            decrypted_data = unpad(cipher.decrypt(data[AES.block_size:]), AES.block_size)
            print("Data decrypted successfully.")
            return decrypted_data
        except Exception as e:
            print(f"Error decrypting data: {e}")
            return None

    @staticmethod
    def generate_rsa_keys(bits: int = 2048) -> Dict[str, str]:
        """
        Generates RSA key pairs.
        :param bits: Key size in bits.
        :return: Dictionary with 'private_key' and 'public_key'.
        """
        print(f"Generating RSA keys with {bits} bits...")
        key = RSAKey.generate(bits)
        private_key = key.export_key().decode()
        public_key = key.publickey().export_key().decode()
        print("RSA keys generated successfully.")
        return {"private_key": private_key, "public_key": public_key}

    @staticmethod
    def encrypt_rsa(data: bytes, public_key: str) -> bytes:
        """
        Encrypts data using RSA public key encryption.
        :param data: Data to encrypt.
        :param public_key: RSA public key.
        :return: Encrypted data.
        """
        print("Encrypting data using RSA...")
        pub_key = RSAKey.import_key(public_key)
        cipher = RSA.construct((pub_key.n, pub_key.e))
        encrypted_data = cipher.encrypt(data, None)[0]
        print("Data encrypted successfully.")
        return encrypted_data

    @staticmethod
    def decrypt_rsa(data: bytes, private_key: str) -> Optional[bytes]:
        """
        Decrypts RSA-encrypted data using a private key.
        :param data: Encrypted data.
        :param private_key: RSA private key.
        :return: Decrypted data or None if decryption fails.
        """
        print("Decrypting RSA-encrypted data...")
        try:
            priv_key = RSAKey.import_key(private_key)
            cipher = RSA.construct((priv_key.n, priv_key.d))
            decrypted_data = cipher.decrypt(data)
            print("Data decrypted successfully.")
            return decrypted_data
        except Exception as e:
            print(f"Error decrypting data: {e}")
            return None


class CryptoAnalysisTester:
    """
    A class to test the functionalities of CryptoAnalyzer.
    """

    @staticmethod
    def run_tests():
        """
        Runs a series of cryptographic tests.
        """
        print("Starting cryptographic analysis tests...")

        # Test hashing
        sample_data = b"Test data for hashing"
        file_hash = hashlib.sha256(sample_data).hexdigest()
        print("Sample Hash:", file_hash)

        # Test AES encryption/decryption
        aes_key = get_random_bytes(16)
        encrypted_data = CryptoAnalyzer.encrypt_aes(sample_data, aes_key)
        decrypted_data = CryptoAnalyzer.decrypt_aes(encrypted_data, aes_key)
        print("Decrypted AES Data:", decrypted_data)

        # Test RSA key generation and encryption/decryption
        rsa_keys = CryptoAnalyzer.generate_rsa_keys()
        encrypted_rsa_data = CryptoAnalyzer.encrypt_rsa(sample_data, rsa_keys['public_key'])
        decrypted_rsa_data = CryptoAnalyzer.decrypt_rsa(encrypted_rsa_data, rsa_keys['private_key'])
        print("Decrypted RSA Data:", decrypted_rsa_data)


if __name__ == "__main__":
    # Example Usage
    CryptoAnalysisTester.run_tests()
