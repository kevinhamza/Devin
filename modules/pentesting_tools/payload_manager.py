"""
modules/pentesting_tools/payload_manager.py

This module provides utilities for managing and deploying pentesting payloads.
It allows users to create, customize, deploy, and track payloads during
penetration testing activities.
"""

import os
import json
import subprocess
from datetime import datetime


class PayloadManager:
    """
    A class to manage pentesting payloads.
    """

    PAYLOAD_STORAGE_PATH = "data/payloads"  # Directory to store payload files

    def __init__(self):
        """
        Initializes the payload manager, ensuring the payload storage directory exists.
        """
        os.makedirs(self.PAYLOAD_STORAGE_PATH, exist_ok=True)

    def list_payloads(self):
        """
        Lists all available payloads in the storage directory.
        :return: List of payload filenames.
        """
        return [file for file in os.listdir(self.PAYLOAD_STORAGE_PATH) if file.endswith(".json")]

    def create_payload(self, name, description, commands):
        """
        Creates a new payload and saves it to a JSON file.
        :param name: Name of the payload.
        :param description: Description of the payload's purpose.
        :param commands: List of commands to be executed by the payload.
        :return: Path to the saved payload file.
        """
        payload = {
            "name": name,
            "description": description,
            "commands": commands,
            "created_at": datetime.now().isoformat(),
        }

        filepath = os.path.join(self.PAYLOAD_STORAGE_PATH, f"{name}.json")
        with open(filepath, "w") as file:
            json.dump(payload, file, indent=4)

        print(f"Payload '{name}' created successfully.")
        return filepath

    def load_payload(self, name):
        """
        Loads a payload from the storage directory.
        :param name: Name of the payload file (without extension).
        :return: Payload data as a dictionary, or None if not found.
        """
        filepath = os.path.join(self.PAYLOAD_STORAGE_PATH, f"{name}.json")
        if not os.path.exists(filepath):
            print(f"Payload '{name}' does not exist.")
            return None

        with open(filepath, "r") as file:
            return json.load(file)

    def execute_payload(self, name):
        """
        Executes a payload by running its commands sequentially.
        :param name: Name of the payload file (without extension).
        """
        payload = self.load_payload(name)
        if not payload:
            return

        print(f"Executing payload '{name}'...")
        for command in payload["commands"]:
            try:
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                print(f"> {command}\n{result.stdout}")
                if result.stderr:
                    print(f"Error: {result.stderr}")
            except Exception as e:
                print(f"Error executing command '{command}': {e}")

    def delete_payload(self, name):
        """
        Deletes a payload file.
        :param name: Name of the payload file (without extension).
        """
        filepath = os.path.join(self.PAYLOAD_STORAGE_PATH, f"{name}.json")
        if os.path.exists(filepath):
            os.remove(filepath)
            print(f"Payload '{name}' deleted successfully.")
        else:
            print(f"Payload '{name}' not found.")

    def update_payload(self, name, new_description=None, new_commands=None):
        """
        Updates an existing payload's description or commands.
        :param name: Name of the payload file (without extension).
        :param new_description: New description for the payload (optional).
        :param new_commands: New commands for the payload (optional).
        :return: Updated payload data, or None if the payload doesn't exist.
        """
        payload = self.load_payload(name)
        if not payload:
            return None

        if new_description:
            payload["description"] = new_description
        if new_commands:
            payload["commands"] = new_commands

        filepath = os.path.join(self.PAYLOAD_STORAGE_PATH, f"{name}.json")
        with open(filepath, "w") as file:
            json.dump(payload, file, indent=4)

        print(f"Payload '{name}' updated successfully.")
        return payload


if __name__ == "__main__":
    # Example Usage
    manager = PayloadManager()

    # Creating a payload
    manager.create_payload(
        "example_payload",
        "Example payload for demonstration purposes.",
        ["echo 'Payload Execution Started'", "whoami", "ls -l"],
    )

    # Listing payloads
    print("\nAvailable Payloads:")
    print(manager.list_payloads())

    # Executing a payload
    manager.execute_payload("example_payload")

    # Updating a payload
    manager.update_payload(
        "example_payload", new_description="Updated example payload", new_commands=["echo 'New Commands'", "date"]
    )

    # Deleting a payload
    manager.delete_payload("example_payload")
