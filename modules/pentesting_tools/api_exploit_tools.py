"""
modules/pentesting_tools/api_exploit_tools.py

Tools for testing API vulnerabilities such as insecure endpoints, improper authentication, and more.
"""

import requests
from typing import Dict, Any, Optional

class APIExploitTools:
    """
    A toolkit for assessing and exploiting API vulnerabilities.
    """

    def __init__(self, base_url: str):
        """
        Initializes the APIExploitTools class.
        :param base_url: The base URL of the target API.
        """
        self.base_url = base_url.rstrip("/")

    def test_endpoint(self, endpoint: str, method: str = "GET", headers: Optional[Dict[str, str]] = None, params: Optional[Dict[str, Any]] = None, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Tests an API endpoint for response and potential issues.
        :param endpoint: The endpoint to test.
        :param method: HTTP method (GET, POST, PUT, DELETE).
        :param headers: Optional headers to include in the request.
        :param params: Query parameters for the request.
        :param data: Data payload for POST/PUT requests.
        :return: Response and metadata.
        """
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        headers = headers or {}
        params = params or {}
        data = data or {}

        try:
            print(f"Testing endpoint {url} with method {method}")
            if method.upper() == "GET":
                response = requests.get(url, headers=headers, params=params)
            elif method.upper() == "POST":
                response = requests.post(url, headers=headers, data=data)
            elif method.upper() == "PUT":
                response = requests.put(url, headers=headers, data=data)
            elif method.upper() == "DELETE":
                response = requests.delete(url, headers=headers, params=params)
            else:
                return {"error": f"Unsupported HTTP method: {method}"}

            return {
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "body": response.text,
                "elapsed_time": response.elapsed.total_seconds(),
            }
        except requests.RequestException as e:
            print(f"Error testing endpoint {url}: {e}")
            return {"error": str(e)}

    def test_authentication_bypass(self, endpoint: str, method: str = "GET", params: Optional[Dict[str, Any]] = None, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Tests an endpoint for authentication bypass vulnerabilities.
        :param endpoint: The endpoint to test.
        :param method: HTTP method (GET, POST, etc.).
        :param params: Query parameters for the request.
        :param data: Data payload for POST/PUT requests.
        :return: Response data and analysis.
        """
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        headers = {}  # Intentionally leaving headers empty to simulate unauthenticated requests.

        print(f"Testing authentication bypass on {url}")
        return self.test_endpoint(endpoint, method, headers=headers, params=params, data=data)

    def test_sql_injection(self, endpoint: str, param_name: str, payloads: list, method: str = "GET") -> Dict[str, Any]:
        """
        Tests for SQL injection vulnerabilities on a given endpoint.
        :param endpoint: The endpoint to test.
        :param param_name: The parameter name to inject payloads into.
        :param payloads: A list of SQL payloads to test.
        :param method: HTTP method (GET, POST).
        :return: A dictionary of results with payloads and responses.
        """
        results = {}
        print(f"Testing SQL injection on {endpoint} with {len(payloads)} payloads")
        for payload in payloads:
            params = {param_name: payload}
            response = self.test_endpoint(endpoint, method=method, params=params)
            results[payload] = response

        return results

    def test_rate_limiting(self, endpoint: str, request_count: int = 100, method: str = "GET") -> Dict[str, Any]:
        """
        Tests an endpoint for rate-limiting issues.
        :param endpoint: The endpoint to test.
        :param request_count: Number of requests to send.
        :param method: HTTP method (GET, POST).
        :return: A dictionary containing response statuses and timings.
        """
        print(f"Testing rate limiting on {endpoint} with {request_count} requests")
        statuses = []
        timings = []
        for _ in range(request_count):
            response = self.test_endpoint(endpoint, method=method)
            statuses.append(response.get("status_code", "error"))
            timings.append(response.get("elapsed_time", 0))

        return {"statuses": statuses, "timings": timings}

    def test_unauthorized_access(self, endpoint: str, headers: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
        """
        Tests an endpoint for unauthorized access vulnerabilities.
        :param endpoint: The endpoint to test.
        :param headers: Headers to include in the request, if any.
        :return: Response data and analysis.
        """
        headers = headers or {}
        print(f"Testing unauthorized access on {endpoint}")
        return self.test_endpoint(endpoint, headers=headers)

if __name__ == "__main__":
    # Example Usage
    base_url = "https://example-api.com"
    api_tool = APIExploitTools(base_url)

    # Test a sample endpoint
    response = api_tool.test_endpoint("test_endpoint", method="GET")
    print(response)

    # Test SQL Injection
    sql_payloads = ["' OR 1=1 --", "'; DROP TABLE users; --"]
    sql_results = api_tool.test_sql_injection("vulnerable_endpoint", "user", sql_payloads)
    print(sql_results)
