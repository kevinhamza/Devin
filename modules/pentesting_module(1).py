"""
Pentesting Module
Ethical hacking and vulnerability assessment tools for identifying system security weaknesses.
"""

import os
import subprocess
from typing import List, Dict, Any


class PentestingToolkit:
    """
    A collection of tools and utilities for ethical hacking and vulnerability assessments.
    """

    def __init__(self):
        """
        Initialize the Pentesting Toolkit.
        """
        self.tools = {
            "nmap": "Network scanning and port discovery",
            "sqlmap": "SQL injection testing",
            "dirb": "Directory brute-forcing",
            "metasploit": "Exploitation framework",
            "burpsuite": "Web application security testing",
        }

    def list_tools(self) -> Dict[str, str]:
        """
        List available pentesting tools with their descriptions.

        Returns:
            Dict[str, str]: Dictionary of tools and their descriptions.
        """
        return self.tools

    def execute_tool(self, tool_name: str, options: List[str]) -> str:
        """
        Execute a specified pentesting tool with provided options.

        Args:
            tool_name (str): The name of the tool to execute.
            options (List[str]): Command-line options for the tool.

        Returns:
            str: Output of the tool's execution.
        """
        if tool_name not in self.tools:
            return f"Tool '{tool_name}' is not available in the toolkit."

        try:
            command = [tool_name] + options
            result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            return result.stdout if result.returncode == 0 else result.stderr
        except FileNotFoundError:
            return f"Tool '{tool_name}' is not installed or not available in the system PATH."
        except Exception as e:
            return f"Error executing '{tool_name}': {e}"


class VulnerabilityScanner:
    """
    A scanner for detecting vulnerabilities in systems, networks, and applications.
    """

    @staticmethod
    def scan_ports(target: str, ports: str = "1-65535") -> str:
        """
        Perform a port scan on the target using nmap.

        Args:
            target (str): Target IP or domain.
            ports (str): Port range to scan.

        Returns:
            str: Output of the nmap scan.
        """
        try:
            command = ["nmap", "-p", ports, target]
            result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            return result.stdout if result.returncode == 0 else result.stderr
        except FileNotFoundError:
            return "nmap is not installed or not available in the system PATH."
        except Exception as e:
            return f"Error during port scan: {e}"

    @staticmethod
    def sql_injection_test(target_url: str) -> str:
        """
        Perform an SQL injection test on the target URL using sqlmap.

        Args:
            target_url (str): The URL to test.

        Returns:
            str: Output of the sqlmap test.
        """
        try:
            command = ["sqlmap", "-u", target_url, "--batch"]
            result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            return result.stdout if result.returncode == 0 else result.stderr
        except FileNotFoundError:
            return "sqlmap is not installed or not available in the system PATH."
        except Exception as e:
            return f"Error during SQL injection test: {e}"

    @staticmethod
    def directory_bruteforce(target_url: str, wordlist: str) -> str:
        """
        Perform a directory brute-force attack on the target URL using dirb.

        Args:
            target_url (str): The URL to test.
            wordlist (str): Path to the wordlist file.

        Returns:
            str: Output of the dirb attack.
        """
        try:
            command = ["dirb", target_url, wordlist]
            result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            return result.stdout if result.returncode == 0 else result.stderr
        except FileNotFoundError:
            return "dirb is not installed or not available in the system PATH."
        except Exception as e:
            return f"Error during directory brute-force: {e}"


class PentestingReports:
    """
    Handles the generation and storage of pentesting reports.
    """

    @staticmethod
    def save_report(report_data: str, filename: str, report_dir: str = "pentesting_reports"):
        """
        Save a pentesting report to a file.

        Args:
            report_data (str): The data to save in the report.
            filename (str): Name of the report file.
            report_dir (str): Directory to save the report.
        """
        os.makedirs(report_dir, exist_ok=True)
        report_path = os.path.join(report_dir, filename)

        with open(report_path, "w") as file:
            file.write(report_data)

    @staticmethod
    def read_report(filename: str, report_dir: str = "pentesting_reports") -> str:
        """
        Read a saved pentesting report.

        Args:
            filename (str): Name of the report file.
            report_dir (str): Directory containing the report.

        Returns:
            str: Contents of the report file.
        """
        report_path = os.path.join(report_dir, filename)

        if not os.path.exists(report_path):
            return f"Report '{filename}' not found in '{report_dir}'."

        with open(report_path, "r") as file:
            return file.read()


# Example Usage
if __name__ == "__main__":
    toolkit = PentestingToolkit()
    scanner = VulnerabilityScanner()
    reports = PentestingReports()

    # List available tools
    print("Available Tools:", toolkit.list_tools())

    # Perform a port scan
    target_ip = "192.168.1.1"
    port_scan_report = scanner.scan_ports(target_ip, ports="22,80,443")
    print("Port Scan Report:\n", port_scan_report)

    # Save the report
    reports.save_report(port_scan_report, "port_scan_report.txt")
    print("Report saved successfully.")

    # Read the saved report
    saved_report = reports.read_report("port_scan_report.txt")
    print("Saved Report Content:\n", saved_report)
